# GitHub Copilot Instructions

## Priority Guidelines

When generating code for this repository:

1. **Version Compatibility**: Always detect and respect the exact versions of languages, frameworks, and libraries used in this project
2. **Context Files**: Prioritize patterns and standards defined in the .github/copilot directory
3. **Codebase Patterns**: When context files don't provide specific guidance, scan the codebase for established patterns
4. **Architectural Consistency**: Maintain the monorepo structure with separate frontend and blockchain workspaces
5. **Code Quality**: Prioritize maintainability, type safety, and accessibility in all generated code

## Technology Stack

### Project Structure
- **Monorepo**: pnpm workspace with two main packages
  - `frontend/`: Next.js application with React 19
  - `blockchain/`: Hardhat development environment with Solidity contracts
- **Package Manager**: pnpm@10.18.0 (strict - do not use npm or yarn)

### Frontend Technologies
- **Framework**: Next.js 15.5.6 with Turbopack
- **React**: 19.1.0
- **TypeScript**: ^5 (ES2017 target)
- **Styling**: Tailwind CSS 4 with CSS variables for theming
- **UI Components**: shadcn/ui (New York style) with Radix UI primitives
- **Web3**: wagmi@^2.18.1, viem@^2.38.3
- **State Management**: @tanstack/react-query@^5.90.5
- **Theming**: next-themes@^0.4.6
- **Icons**: lucide-react@^0.546.0
- **Utilities**: 
  - class-variance-authority@^0.7.1
  - clsx@^2.1.1
  - tailwind-merge@^3.3.1
- **Code Quality**: Biome 2.2.0 (linter and formatter)

### Blockchain Technologies
- **Smart Contracts**: Solidity ^0.8.28
- **Development Framework**: Hardhat 3.0.7
- **TypeScript**: ~5.8.3 (ES2022 target, Node16 module)
- **Testing**: Hardhat Toolbox with Viem
- **Code Generation**: @wagmi/cli@^2.7.0
- **Libraries**: viem@^2.38.3 for contract interactions

## TypeScript Standards

### Strict Type Safety
- **NO `any` types**: Always use proper TypeScript types
- **Explicit typing**: Type all function parameters and return values
- **Component props**: Always use `React.ComponentProps<T>` or explicit interfaces
- **Generics**: Use where appropriate for reusable components and functions
- **Type imports**: Use `import type` for type-only imports

### TypeScript Patterns from Codebase

#### Frontend (Next.js App Router)
```typescript
// Component typing pattern
function Component({ 
  children,
  className,
  ...props 
}: React.ComponentProps<"div">) {
  return <div className={cn("base-classes", className)} {...props}>{children}</div>
}

// Provider pattern with proper typing
export function Provider({ children }: { children: ReactNode }) {
  const [client] = useState(() => new QueryClient())
  return <QueryClientProvider client={client}>{children}</QueryClientProvider>
}

// Config with module augmentation
declare module 'wagmi' {
  interface Register {
    config: typeof config
  }
}
```

#### Blockchain (Hardhat)
```typescript
// Hardhat config typing
import type { HardhatUserConfig } from "hardhat/config";

const config: HardhatUserConfig = {
  // configuration
};

export default config;

// Test typing
import assert from "node:assert/strict";
import { describe, it } from "node:test";

describe("Contract", async function () {
  const { viem } = await network.connect();
  // tests
});
```

## Code Organization Patterns

### Frontend Structure
- **App Router**: Use Next.js 15 app directory structure
- **Route Groups**: Use `(app)` for authenticated routes
- **Component Location**:
  - UI components: `src/components/ui/`
  - Custom components: `src/components/`
  - Hooks: `src/hooks/`
  - Utils: `src/lib/`
- **File Naming**: kebab-case for files, PascalCase for components

### Blockchain Structure
- **Contracts**: `contracts/*.sol`
- **Tests**: `test/*.ts` (matches contract name)
- **Deployment**: `ignition/modules/*.ts`
- **Scripts**: `scripts/*.ts`
- **Generated**: `generated.ts` (auto-generated by wagmi CLI)

## Component Patterns

### shadcn/ui Component Structure
Follow the exact pattern used in existing components:

```typescript
import * as React from "react"
import { cn } from "@/lib/utils"

function Component({ 
  className, 
  ...props 
}: React.ComponentProps<"element">) {
  return (
    <element
      data-slot="component"
      className={cn(
        "base classes with design tokens",
        className
      )}
      {...props}
    />
  )
}

export { Component }
```

### Component Variant Pattern
Use `class-variance-authority` for component variants:

```typescript
import { cva, type VariantProps } from "class-variance-authority"

const componentVariants = cva(
  "base classes",
  {
    variants: {
      variant: {
        default: "variant classes",
        other: "other variant classes",
      },
      size: {
        default: "size classes",
        sm: "small size classes",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Component({
  className,
  variant,
  size,
  ...props
}: React.ComponentProps<"element"> & VariantProps<typeof componentVariants>) {
  return (
    <element 
      className={cn(componentVariants({ variant, size, className }))} 
      {...props} 
    />
  )
}
```

### Client vs Server Components
- **Server Components** (default): No 'use client' directive
- **Client Components**: Add `'use client'` at top when using:
  - React hooks (useState, useEffect, etc.)
  - Browser APIs
  - Event handlers
  - wagmi hooks
  - React Query

Example from codebase:
```typescript
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from '@/lib/wagmi'
import { ReactNode, useState } from 'react'

export function Providers({ children }: { children: ReactNode }) {
  const [queryClient] = useState(() => new QueryClient())
  // client-side logic
}
```

## Styling Standards

### CSS Variables for Theming
**CRITICAL**: Always use CSS variables from the design system. NEVER hardcode colors.

#### Color Usage
```typescript
// ✅ CORRECT - Uses CSS variables
className="bg-background text-foreground border-border"
className="bg-primary text-primary-foreground"
className="hover:bg-accent hover:text-accent-foreground"

// ❌ WRONG - Hardcoded colors
className="bg-white text-black border-gray-200"
className="bg-blue-500 text-white"
```

#### Available Color Tokens
From `globals.css`:
- **Background/Foreground**: `background`, `foreground`
- **Cards**: `card`, `card-foreground`
- **Popover**: `popover`, `popover-foreground`
- **Primary**: `primary`, `primary-foreground`
- **Secondary**: `secondary`, `secondary-foreground`
- **Muted**: `muted`, `muted-foreground`
- **Accent**: `accent`, `accent-foreground`
- **Destructive**: `destructive`
- **Border/Input**: `border`, `input`, `ring`
- **Sidebar**: `sidebar`, `sidebar-foreground`, `sidebar-primary`, `sidebar-accent`, etc.
- **Charts**: `chart-1` through `chart-5`

#### Radius Tokens
Use radius variables: `radius-sm`, `radius-md`, `radius-lg`, `radius-xl`

### Tailwind CSS Patterns
```typescript
// Spacing and layout
className="flex items-center gap-2 p-4"

// Responsive design
className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3"

// Dark mode (automatic with CSS variables)
className="bg-background dark:bg-background" // Not needed - use just bg-background

// Focus states
className="outline-none focus-visible:ring-2 focus-visible:ring-ring"
```

### Component Slot Pattern
Use `data-slot` attributes for component identification:
```typescript
<div data-slot="card-header">
<div data-slot="card-title">
<button data-slot="button">
```

## Web3 Integration Patterns

### wagmi Configuration
```typescript
import { http, createConfig } from 'wagmi'
import { hardhat, sepolia } from 'wagmi/chains'

export const config = createConfig({
  chains: [hardhat, sepolia],
  transports: {
    [hardhat.id]: http(),
    [sepolia.id]: http(),
  },
})

// Always include module augmentation
declare module 'wagmi' {
  interface Register {
    config: typeof config
  }
}
```

### Contract Integration
- Use generated types from `blockchain/generated.ts`
- Import ABIs and contract configs from the generated file
- Use viem for type-safe contract interactions

### Hardhat Patterns
```typescript
// Contract deployment in tests
const { viem } = await network.connect();
const contract = await viem.deployContract("ContractName");

// Event assertions
await viem.assertions.emitWithArgs(
  contract.write.method(),
  contract,
  "EventName",
  [expectedArgs],
);

// Reading events
const publicClient = await viem.getPublicClient();
const events = await publicClient.getContractEvents({
  address: contract.address,
  abi: contract.abi,
  eventName: "EventName",
  fromBlock: deploymentBlockNumber,
  strict: true,
});
```

## Utility Functions

### cn() Helper
Always use the `cn()` utility for className merging:
```typescript
import { cn } from "@/lib/utils"

className={cn("base-classes", conditionalClass && "conditional", className)}
```

Implementation:
```typescript
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

## Code Quality Standards

### Maintainability
- Keep functions focused and single-purpose
- Use descriptive variable and function names
- Modularize into smaller files when components exceed ~100-150 lines
- Extract reusable logic into hooks or utility functions
- Keep components readable and manageable

### Accessibility
- Use semantic HTML elements
- Include proper ARIA attributes on interactive elements
- Ensure keyboard navigation support
- Follow patterns from existing shadcn/ui components
- Use focus-visible states consistently

### Performance
- Use React.memo() only when necessary (profile first)
- Lazy load heavy components
- Use proper React hooks dependency arrays
- Leverage Next.js image optimization
- Keep bundle size minimal

## Testing Standards

### Blockchain Tests (Node Test Runner)
```typescript
import assert from "node:assert/strict";
import { describe, it } from "node:test";
import { network } from "hardhat";

describe("ContractName", async function () {
  const { viem } = await network.connect();
  const publicClient = await viem.getPublicClient();

  it("Should do something", async function () {
    const contract = await viem.deployContract("ContractName");
    // test logic with assertions
    assert.equal(expected, actual);
  });
});
```

### Test Organization
- One test file per contract
- Use descriptive test names
- Test both success and failure cases
- Verify events are emitted correctly
- Test state changes comprehensively

## Biome Configuration

### Code Style
- **Indentation**: 2 spaces
- **Quote Style**: Single quotes (default)
- **Semicolons**: Required
- **Import Organization**: Enabled (auto-organize on format)
- **Line Width**: Default

### Linting
- All recommended rules enabled
- Next.js domain rules: recommended
- React domain rules: recommended
- Unknown CSS at-rules disabled (for Tailwind)

### Commands
- Check: `pnpm lint` (in frontend/)
- Format: `pnpm format` (in frontend/)

## File Naming Conventions

### Frontend
- Components: PascalCase (e.g., `Button.tsx`, `UserProfile.tsx`)
- Utilities: kebab-case (e.g., `use-mobile.ts`, `utils.ts`)
- Pages: kebab-case (e.g., `page.tsx`, `layout.tsx`)
- Route folders: kebab-case or (grouped)

### Blockchain
- Contracts: PascalCase (e.g., `Counter.sol`)
- Tests: Match contract name (e.g., `Counter.ts`)
- Scripts: kebab-case (e.g., `send-op-tx.ts`)
- Modules: PascalCase (e.g., `Counter.ts`)

## Import Organization

### Import Order (Biome auto-organizes)
1. External dependencies
2. Internal workspace packages
3. Relative imports (parent directories)
4. Relative imports (same directory)

### Import Patterns
```typescript
// Type-only imports
import type { HardhatUserConfig } from "hardhat/config";

// Component imports
import { Button } from "@/components/ui/button"
import { Card, CardHeader, CardTitle } from "@/components/ui/card"

// Utility imports
import { cn } from "@/lib/utils"

// React imports
import { useState, useEffect, type ReactNode } from 'react'
```

## Solidity Standards

### Version
- **Version**: ^0.8.28 (strict)
- **License**: UNLICENSED (default)

### Code Style
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

contract ContractName {
  // State variables
  uint public stateVar;

  // Events
  event EventName(uint indexed param);

  // Functions
  function functionName() public {
    stateVar++;
    emit EventName(stateVar);
  }

  function functionWithRequire(uint param) public {
    require(param > 0, "functionName: validation message");
    // logic
  }
}
```

### Patterns
- Use explicit visibility modifiers
- Emit events for state changes
- Use descriptive require messages with function name prefix
- Keep contracts focused and modular

## Build and Development Commands

### Frontend
```bash
pnpm dev                    # Start dev server with Turbopack
pnpm build                  # Build frontend (includes blockchain build)
pnpm lint                   # Run Biome linter
pnpm format                 # Format code with Biome
```

### Blockchain
```bash
pnpm compile                # Compile Solidity contracts
pnpm generate               # Generate TypeScript types with wagmi CLI
pnpm build                  # Compile + generate
pnpm test                   # Run Hardhat tests
```

### Root
```bash
pnpm build                  # Build both blockchain and frontend
pnpm dev:blockchain         # Compile and generate blockchain types
pnpm dev:frontend           # Start frontend dev server
```

## Project-Specific Guidelines

1. **Type Safety First**: Never use `any`, always use proper TypeScript types
2. **CSS Variables Only**: Never hardcode colors, always use design tokens
3. **Modular Code**: Keep files concise and readable by breaking into smaller modules
4. **shadcn Components**: Use standard shadcn/ui components with proper patterns
5. **Web3 Integration**: Use wagmi/viem for all blockchain interactions
6. **Monorepo Aware**: Understand frontend imports blockchain workspace types
7. **Theme Support**: All styling must support light/dark themes via CSS variables
8. **Accessibility**: Follow WCAG guidelines and existing component patterns
9. **Biome Tools**: Use Biome for all linting and formatting (not ESLint/Prettier)
10. **Package Manager**: Always use pnpm, never npm or yarn

## General Best Practices

- Follow existing code patterns exactly
- Maintain consistency with similar files in the codebase
- Use TypeScript's type system fully - no shortcuts
- Keep components small and focused
- Extract repeated logic into reusable utilities/hooks
- Document complex logic with comments
- Test both happy paths and error cases
- Use semantic HTML and proper ARIA attributes
- Optimize for tree-shaking and bundle size
- Leverage Next.js features (Image, Font, etc.)

## Error Handling

### Frontend
```typescript
// React error boundaries for component errors
// Try-catch for async operations
try {
  const result = await someAsyncOperation();
  // handle result
} catch (error) {
  // handle error appropriately
  console.error('Operation failed:', error);
}
```

### Blockchain
```solidity
// Use require for validation
require(condition, "ContractName: descriptive error message");

// Use revert for complex conditions
if (complexCondition) {
  revert("ContractName: descriptive error message");
}
```

## When In Doubt

1. Check similar files in the codebase first
2. Follow shadcn/ui component patterns
3. Use CSS variables, never hardcode colors
4. Type everything explicitly, never use `any`
5. Keep code modular and maintainable
6. Prioritize consistency over personal preference
